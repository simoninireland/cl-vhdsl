// Generated by VHDSL at 2025-05-05T19:19:47.000000+01:00

// Source: sap-1.lisp

module memory(
    input [ 4 - 1 : 0 ] addr, 
    output [ 8 - 1 : 0 ] data
);

    reg [ 8 - 1 : 0 ] mem[ 0 : 16 - 1 ];

    assign data = mem[ addr ];

endmodule // memory


// Source: sap-1.lisp

module alu(
    input [ 8 - 1 : 0 ] a, 
    input [ 8 - 1 : 0 ] b, 
    input op, 
    output [ 8 - 1 : 0 ] c
);

    assign c = ((op == 0) ? (a + b) : ((op == 1) ? (a - b) : 0));

endmodule // alu


// Source: sap-1.lisp

module core(
    input clk, 
    input rst, 
    output [ 8 - 1 : 0 ] leds
);

    reg [ 4 - 1 : 0 ] pc = 0;
    reg [ 8 - 1 : 0 ] ir = 0;
    reg [ 3 - 1 : 0 ] tstate = 0;
    reg [ 8 - 1 : 0 ] a = 0;
    reg [ 8 - 1 : 0 ] alu_a = 0;
    reg [ 8 - 1 : 0 ] alu_b = 0;
    reg alu_op = 0;
    reg [ 8 - 1 : 0 ] alu_c = 0;
    reg [ 8 - 1 : 0 ] out = 0;
    reg [ 4 - 1 : 0 ] mem_addr = 0;
    reg [ 8 - 1 : 0 ] mem_data = 0;
    memory mem (
        .addr(mem_addr), 
        .data(mem_data)
    );
    alu alu (
        .a(alu_a), 
        .b(alu_b), 
        .op(alu_op), 
        .c(alu_c)
    );
    reg [ 8 - 1 : 0 ] the_opcode = (ir >> 4);
    reg [ 8 - 1 : 0 ] the_address = (ir & 15);
    reg islda = (the_opcode == 0);
    reg isadd = (the_opcode == 1);
    reg issub = (the_opcode == 2);
    reg isout = (the_opcode == 14);
    reg ishlt = (the_opcode == 15);

    assign leds = out;
    if(rst)
    begin
        pc <= 0;
        ir <= 0;
        tstate <= 0;
        out <= 0;
        a <= 0;
    end
    else
    begin
        always @(negedge(clk))
        begin
            case (tstate)
                0:
                    mem_addr <= pc;
                
                2:
                    if(islda)
                    begin
                        mem_addr <= the_address;
                    end
                    else if(isadd)
                    begin
                        mem_addr <= the_address;
                    end
                    else if(issub)
                    begin
                        mem_addr <= the_address;
                    end
                
                3:
                    if(isadd)
                    begin
                        alu_a <= a;
                        alu_op <= 0;
                    end
                    else if(issub)
                    begin
                        alu_a <= a;
                        alu_op <= 1;
                    end
            endcase
        end

        
        always @(posedge(clk))
        begin
            case (tstate)
                0:
                begin
                    ir <= mem_data;
                    tstate <= (tstate + 1);
                end
                
                1:
                begin
                    pc <= (pc + 1);
                    tstate <= (tstate + 1);
                end
                
                2:
                begin
                    alu_b <= mem_data;
                    tstate <= (tstate + 1);
                end
                
                3:
                    if(islda)
                    begin
                        a <= mem_data;
                        tstate <= 0;
                    end
                    else if(isadd)
                    begin
                        a <= alu_c;
                        tstate <= 0;
                    end
                    else if(issub)
                    begin
                        a <= alu_c;
                        tstate <= 0;
                    end
                    else if(isout)
                    begin
                        out <= a;
                        tstate <= 0;
                    end
                    else if(ishlt)
                    begin
                        tstate <= 4;
                    end
            endcase
        end

    end

endmodule // core


