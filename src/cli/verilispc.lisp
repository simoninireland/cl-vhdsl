;; Command line VHDSL-to-Verilog transpiler
;;
;; Copyright (C) 2024--2025 Simon Dobson
;;
;; This file is part of verilisp, a Common Lisp DSL for hardware design
;;
;; verilisp is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; verilisp is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.
;;
;; You should have received a copy of the GNU General Public License
;; along with verilisp. If not, see <http://www.gnu.org/licenses/gpl.html>.

(in-package :verilisp/cli)


;; ---------- Globals ----------

(defvar *errors* 0
  "Number of errors caught.")


(defvar *module-source-file-names* nil
  "Map module names to their source files.")


(defun add-module-source-file-name (modname fn)
  "Add FN as the source file for MODNAME."
  (appendf *module-source-file-names* (list (list modname fn))))


(defun get-module-source-file-name (modname)
  "Retrieve the source file for MODNAME.

Reyirn NIL if the module isn't known."
  (if-let ((m (assoc modname *module-source-file-names*)))
    (cadr m)))


(defun record-new-modules (fn)
  "Record modules loaded from FN into *MODULE-SOURCE-FILE-NAMES*."
  (dolist (mm (get-modules-for-synthesis))
    (destructuring-bind (modname module)
	mm
      (declare (ignore module))
      (unless (get-module-source-file-name modname)
	(add-module-source-file-name modname fn)))))


;; ---------- Command-line options handling ----------

(defvar *verbosity* 0
  "Verbosity (reporting) level (higher is more verbose).")


(defvar *fail-on-load* t
  "If T, don't synthesise any files if there were errors in loading any.")


(defvar *output-file* nil
  "Name of file that gets the synthesised Verilog.

If absent, generate one file per module.")


(defvar *elaborated-file* nil
  "Name of file that gets the elaborated Lisp.

If absent, don;t output the Lisp code.")


(opts:define-opts
  (:name :help
   :description "print this help text"
   :short #\h
   :long "help")
  (:name :verbose
   :description "Verbose output"
   :short #\v
   :long "verbose")
  (:name :continue-on-fail
   :description "Synthesise even if there were errors loading"
   :short #\c
   :long "continue")
  (:name :output-file
   :description "File name for all synthesised code"
   :arg-parser (lambda (fn) (setq *output-file* fn))
   :short #\o
   :long "output-file"
   :meta-var "VERILOG-FILE")
  (:name :elaborated-file
   :description "File name for elaborated Lisp code"
   :arg-parser (lambda (fn) (setq *elaborated-file* fn))
   :short #\e
   :long "elaborated-file"
   :meta-var "LISP-FILE"))


(defun unknown-option (condition)
  (format t "warning: ~s option is unknown~%" (opts:option condition))
  (invoke-restart 'skip-option))


(defmacro when-option ((options opt) &body body)
  "Run forms in BODY when OPT if defined in OPTIONS."
  `(let ((it (getf ,options ,opt)))
     (when it
       ,@body)))


(defun parse-command-line ()
  "Parse the command line options.

This will set the various status flags and return
a list of files to be processed."
  ;; parse the command-line arguments
  (multiple-value-bind (options free-args)
      (handler-case
	  (handler-bind
	      ((opts:unknown-option #'unknown-option))
	    (opts:get-opts))

	(opts:missing-arg (condition)
	  (format t "Option ~s needs an argument~%"
		  (opts:option condition)))
	(opts:arg-parser-failed (condition)
	  (format t "Cannot parse ~s as argument of ~s~%"
		  (opts:raw-arg condition)
		  (opts:option condition)))
	(opts:missing-required-option (con)
	  (format t "Fatal: ~a~%" con)
	  (uiop:quit 1)))

    (when-option (options :verbose)
      (setq *verbosity* 1))
    (when-option (options :continue-on-fail)
      (setq *fail-on-load* nil))
    (when-option (options :help)
      (opts:describe
	:prefix   "Transpiler from Verilisp to Verilog."
	:suffix   "Lisp files can use all of Lisp."
	:usage-of (car (opts:argv))
	:args     "[LISP-FILES]")
      (uiop:quit 0))

    ;; return the files, which are all the non-option arguments
    free-args))


;; ---------- File handling ----------

(defun filename-for-module (modname)
  "Return the filename used to store module MODNAME.

The filename is the name of the module in lowwr case with
a .v (Verilog) extension."
  (format nil "~(~a~).v" modname))


(defun iso-8601-timestamp ()
  "Return the ISO 8602 (RFC3339) timestamp for the current time.

See https://en.wikipedia.org/wiki/ISO_8601"
  (format-rfc3339-timestring nil (universal-to-timestamp (get-universal-time))))


(defun file-header ()
  "Return the file header placed at the top of each synthesised file.

The header will need to be preceded by an appropriate comment string."
  (format nil "Generated by VHDSL at ~a~%" (iso-8601-timestamp)))


(defun filename-header (fn)
  "Return the header for synthesising FN.

FN should be the name of the Lisp file giving rise to the synthesised
Verilog.

The header will need to be preceded by an appropriate comment string."
  (format nil "Source: ~a~%" fn))


;; ---------- Errors and progress reporting ----------

(defun info (format &rest args)
  "Generate a info  message when we're in verbose mode."
  (when (> *verbosity* 0)
    (let ((line (format nil "~a~%" format)))
      (apply #'format `(*standard-output* ,line ,@args)))))


;; ---------- Main function ----------

;; Package used to hold loaded code
(defpackage cl-vhdsl/cli/compiling
  (:use :cl :cl-vhdsl/rtl))


(defun main ()
  (let ((files (parse-command-line)))

    ;; quit if no files given
    (when (= (length files) 0)
      (format *error-output* "No input files given~%")
      (uiop:quit 0))

    (handler-bind
	((error (lambda (c)
		  (format *error-output* "~a~%" c)
		  (incf *errors*)
		  (invoke-restart 'ignore-file-with-errors))))

      ;; load all the source files in order
      (let ((*package* (find-package :verilisp/cli/compiling)))
	(dolist (fn files)
	  (restart-case
	      (progn
		;; use standard input if - appears as a filename
		;; TBD

		(info "Loading ~a~%" fn)
		(load fn :if-does-not-exist t)
		(record-new-modules fn))

	    (ignore-file-with-errors ()
	      :report "Ignore this file and continue"
	      nil))))

      ;; check whether to bail out
      (when (and *fail-on-load*
		 (> *errors* 0))
	(format *error-output* "~a errors~%" *errors*)
	(format *error-output* "Not synthsising")
	(uiop:quit 1))

      ;; generate elaborated Lisp if requested
      (if *elaborated-file*
	  (with-open-file (str *elaborated-file* :direction :output
						 :if-exists :supersede)
	    (format str ";; ")
	    (format str (file-header))
	    (format str "~%")

	    (info "Writing elaborated Lisp to ~a~%" *elaborated-file*)
	    (let ((*print-case* :downcase)
		  (*print-base* 10)
		  (*package* (find-package :verilisp/cli/compiling)))
	      (dolist (mm (get-modules-for-synthesis))
		(restart-case
		    (destructuring-bind (modname module)
			mm
		      (let ((fn (get-module-source-file-name modname)))
			(format str ";; ")
			(format str (filename-header fn)))
		      (pprint module str)
		      (format str "~%~%"))

		  (ignore-file-with-errors ()
		    :report "Abandon outputing this file and continue"
		    nil))))))

      ;; generate output
      (if *output-file*
	  ;; generate one file for all modules
	  (with-open-file (str *output-file* :direction :output
					     :if-exists :supersede)
	    (format str "// ")
	    (format str (file-header))
	    (format str "~%")

	    (info "Compiling all modules to ~a~%" *output-file*)
	    (dolist (mm (get-modules-for-synthesis))
	      (restart-case
		  (destructuring-bind (modname module)
		      mm
		    (info "Compiling ~a~%" modname)
		    (let ((fn (get-module-source-file-name modname)))
		      (format str "// ")
		      (format str (filename-header fn))
		      (format str "~%"))
		    (synthesise-module module str)
		    (format str "~%"))

		(ignore-file-with-errors ()
		  :report "Abandon synthesising this file and continue"
		  nil))))

	  ;; generate the Verilog for each module
	  (dolist (mm (get-modules-for-synthesis))
	    (restart-case
		(destructuring-bind (modname module)
		    mm
		  (let ((fn (filename-for-module modname)))
		    (info "Compiling ~a to ~a~%" modname fn)
		    (with-open-file (str fn :direction :output
					    :if-exists :supersede)
		      (format str "// ")
		      (format str (file-header))
		      (format str (filename-header fn))
		      (format str "~%")

		      (synthesise-module module str))))

	      (ignore-file-with-errors ()
		:report "Abandon synthesising this file and continue"
		nil)))))

    ;; report errors if there were any
    (when (> *errors* 0)
      (info "~a errors~%" *errors*))

    ;; quit
    (uiop:quit (if (> *errors* 0)
		   1
		   0))))
